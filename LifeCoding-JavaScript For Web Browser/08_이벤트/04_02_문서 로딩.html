<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>문서 로딩</title>
  <!-- 웹페이지를 프로그래밍적으로 제어하기 위해서는 웹페이지의 모든 요소에 대한 처리가 끝나야 한다. 이것을 알려주는 이벤트가 load, DOMContentLoaded이다. -->
  <script>
    var t = document.getElementById('target');
    console.log("head 태그 안 스크립트 : " + t);
    /* 위 코드의 실행결과는 null이다. <p id="target">Hello</p>가 로딩되기 전에 자바스크립트가 실행되었기 때문이다. */
  </script>

  <!-- 또 다른 방법은 load 이벤트를 이용하는 것이다. -->
  <script>
    /* window.onload = function () {
      // onload는 웹페이지 전체가 브라우저에 의해 해석이 모두 끝나고 모든 리소스까지 다운로드가 끝난 후 onload가 호출되도록 약속되어 있음
      var t = document.getElementById('target');
      console.log("load 이벤트 이용 : " + t);
    } */
    // 프로퍼티 방식을 addEventListener 방식으로만 변경함. 같은 코드
    window.addEventListener('load', function () {
      var t = document.getElementById('target');
      console.log("load 이벤트 이용 : " + t);
    })
  </script>

  <!-- 그런데 load 이벤트는 문서내의 모든 리소스(이미지, 스크립트)의 다운로드가 끝난 후에 실행된다. 이것을 에플리케이션의 구동이 너무 지연되는 부작용을 초래할 수 있다.
    
    DOMContentLoaded는 문서에서 스크립트 작업을 할 수 있을 때 실행되기 때문에 이미지 다운로드를 기다릴 필요가 없다. -->
  <!-- DOMContentLoaded 이벤트는 IE9을 포함한 모든 브라우저에서 지원하고 있다. -->
  <script>
    window.addEventListener('load', function () {
      console.log('load');
    })
    window.addEventListener('DOMContentLoaded', function () {
      // 다운받아야 되는 리소스를 기다릴 필요 없이 모든 html 태그가 레디 상태가 되는 대로 이벤트 발생
      console.log('DOMContentLoaded');
    })
  </script>
</head>

<body>
  <p id="target">Hello</p>
  <!-- 이를 해결하기 위한 방법은 아래와 같이 스크립트를 문서 끝에 위치시키는 것이다. -->
  <script>
    var t = document.getElementById('target');
    console.log("문서 끝 스크립트 : " + t);
  </script>
</body>

</html>